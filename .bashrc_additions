#### home-bash-configuration -> .bashrc_additions: begin

# --- GnuPG / direnv setup ---
# See `info "(gnupg) Invoking GPG-AGENT"`
export GPG_TTY=$(tty)

# Export empty DIRENV_LOG_FORMAT to silence direnv log output. See
# https://github.com/direnv/direnv/issues/68
export DIRENV_LOG_FORMAT=
eval "$(direnv hook bash)"

# --- History & shell options for convenience ---
shopt -s autocd                  # Type just a directory name to cd into it
shopt -s cdspell                 # Fixe small typos in cd paths
shopt -s checkwinsize            # Update $LINES/$COLUMNS when resizing terminal
HISTCONTROL=ignoredups:erasedups # Avoid clutter in history

# Enlarge history beyond defaults
HISTSIZE=100000
HISTFILESIZE=200000

# --- Functions ---

# In Bash, a script runs in a subshell, so `cd` only changes the directory
# within that subshell. To change the state of the current shell (such as the
# working directory with `cd`), the logic must be implemented as a shell
# function.

# $* vs. $@
# "$*" concatenates all args into a single string, separated by the first
#      character of $IFS (normally a space)
# "$@" treats each arg as its own word.
# -- is a POSIXâ€‘style "end of options" marker

# Clone with git-clone (Scheme procedure) and cd into repo
gicl() {
    git-clone -- "$@" || return

    # Last argument = repo URL
    local url=${!#}

    # Remove a possible trailing slash
    url=${url%/}

    # Strip path and optional .git suffix
    local repo=${url##*/}

    # Remove trailing .git suffix
    repo=${repo%.git}

    cd -- "$repo" || return
}

# mkdir + cd
mkcd() {
    mkdir -p -- "$*" || return
    cd --       "$*" || return
}

# alias for mkcd
take() { mkcd "$@"; }

# Shortcuts for moving up dirs
..()   { cd ..; }
...()  { cd ../..; }
....() { cd ../../..; }

# Directory shortcuts. ${VARNAME:?} guards against unset VARNAME
bin()     { cd ~/bin; }
cheat()   { cd "${cheat:?}"; }
corona()  { cd "${dec:?}/corona_cases"; }
dec()     { cd "${dec:?}"; }
dema()    { cd "${dev:?}/emacs"; }
der()     { cd "${der:?}"; }
desk()    { cd ~/Desktop; }
dev()     { cd "${dev:?}"; }
dgl()     { cd "${dgl:?}"; }
dgx()     { cd "${dgx:?}"; }
dgxp()    { cd "${dgxp:?}"; }
dotf()    { cd "${dotf:?}"; }
down()    { cd ~/Downloads; }
dspd()    { cd "${dspd:?}"; }
dspg()    { cd "${dspg:?}"; }
dspc()    { cd "${dspc:?}"; }
dtf()     { cd "${dtf:?}"; }
dtfg()    { cd "${dtfg:?}"; }
notes()   { cd "${dev:?}/notes/notes"; }
rr()      { cd ~/.config/rash; }
tmp()     { cd /tmp; }
utils()   { cd "${dec:?}/utils"; }
vesmir()  { cd "${der:?}/vesmir"; }
yas()     { cd "${dev:?}/yasnippet"; }

# Quick jump back
cd-() { cd -; }
cdd() { cd -; }

# --- Centralized project directory shortcuts ---
declare -A CDMAP=(
    # variable-based dirs (fail fast if unset)
    # [latest]="$HOME/.cache/guix/checkouts/${latestRepo:?}"
    [owid]="${dec:?}/owid"
    [trackle]="${dev:?}/trackle"
    [ufo]="${dec:?}/ufo"
    [utils]="${dec:?}/utils"
    [zark]="${dec:?}/zark"
)

cdx() {
    local key=$1
    if [[ -z $key ]]; then
        printf 'Usage: cdx <shortcut>\nAvailable: %s\n' "${!CDMAP[@]}" | sort
        return 1
    fi
    local target=${CDMAP[$key]}
    if [[ -z $target ]]; then
        printf 'cdx: unknown shortcut "%s"\n' "$key" >&2
        return 1
    fi
    cd -- "$target" || return
}

# Usage
# $ cdx corona   # goes to $dec/corona_cases
# $ cdx rr       # goes to ~/.config/rash
# $ cdx latest   # goes to ~/.cache/guix/checkouts/$latestRepo

# Benefits
#     Single function (cdx) instead of dozens of small ones.
#     Associative array keeps shortcuts centralized and easy to extend.
#     Usage hint if you run cdx with no args.
#     Error message if you mistype a key.

# --- Bash completion for cdx ---
_cdx_completions() {
    local cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${!CDMAP[@]}" -- "$cur") )
}
complete -F _cdx_completions cdx

# Usage
# $ cdx <TAB>
# latest  owid  trackle  ufo  utils  zark  rr


# Create a quick test repo
create_test_repo() {
    mkdir foo && cd foo || return
    git init
    git config user.email "${GIT_AUTHOR_EMAIL:-x@y.com}"
    git config user.name  "${GIT_AUTHOR_NAME:-Jim Beam}"
    echo "some content" > foo.txt
    git add foo.txt
    git commit -m "1st commit"
    "${EDITOR:-emacs -nw}" foo.txt
}

#### home-bash-configuration -> .bashrc_additions: end

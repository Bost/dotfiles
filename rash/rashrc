#! /usr/bin/env racket
;; emacs - set major mode: SPC h M racket-mode
;; (require rash/demo/demo-rc)

(current-repl-display-startup-hints? #f)

(require racket/string
         racket/function
         linea/line-macro
         shell/pipeline-macro
         (only-in shell/pipeline path-string-symbol?)
         racket/contract/base
         racket/contract/region
         ;; shell/utils/bourne-expansion-utils ; needed?
         ;; needed?
         ;; (for-syntax
         ;;  racket/base
         ;;  syntax/parse
         ;;  )
         )

(require racket/string)
(require racket/function)
(require racket/format)
(require racket/runtime-path)
(require racket/port)

(require rash/demo/setup) ;; defines in-dir

(define-simple-pipeline-alias l    ls -la --color=auto)
(define-simple-pipeline-alias lock xflock4)

(define/contract (change-directory dir)
  (-> path-string-symbol? void?)
  (let ([ps (if (symbol? dir) (symbol->string dir) dir)])
    (if (directory-exists? ps)
        (current-directory ps)
        (error 'change-directory (format "directory doesn't exist: ~a" ps)))))


(define-line-macro utils
  (lambda (_)
    #'(change-directory (string-append (getenv "HOME")
                                       "/dec/utils"))))

(define-line-macro ufo
  (lambda (_)
    #'(change-directory (string-append (getenv "HOME")
                                       "/dec/ufo"))))

(define-line-macro zark
  (lambda (_)
    #'(change-directory (string-append (getenv "HOME")
                                       "/dec/zark"))))

(define-line-macro spa
  (lambda (_)
    #'(change-directory (string-append (getenv "HOME")
                                       "/.emacs.d"))))

(define-line-macro ema
  (lambda (_)
    #'(change-directory (string-append (getenv "HOME")
                                       "/dev/emacs"))))

(define-line-macro ff
  (lambda (_)
    #'(change-directory (string-append (getenv "HOME")
                                       "/.config/fish/functions"))))

(define-line-macro rr
  (lambda (_)
    #'(change-directory (string-append (getenv "HOME")
                                       "/.config/rash"))))

(define-line-macro dev
  (lambda (_)
    #'(change-directory (string-append (getenv "HOME")
                                       "/dev"))))

(define-line-macro dotf
  (lambda (_)
    #'(change-directory (string-append (getenv "HOME")
                                       "/dev/dotf"))))
(define-line-macro cheat
  (lambda (_)
    #'(change-directory (string-append (getenv "HOME")
                                       "/dev/cheat"))))

;; '     adds quote
;; `     adds quasiquote
;; ,     adds unquote
;; ,@    adds unquote-splicing
;; #'    adds syntax
;; #`    adds quasisyntax
;; #,    adds unsyntax
;; #,@   adds unsyntax-splicing

#| racket block comment begin to end |#

;; \|    =unix-pipe=
;; |>    send the result of the previous pipeline segment to a Racket function.
;; \|>   =basic-object-pipe=
;; |>>   =object-pipe=

;; #%   see http://willghatch.net/publications/rash-gpce-2018-preprint.pdf

;; (define x 1234)
;; ;; Now let's see the value of x.
;; ;; We can't just write `x`, but we can do any of these:
;; (values x)
;; |> values x
;; echo $x
;; (require rash/demo/setup)
;; val x

;; {} brace-form
;; Braces read a block of code in line mode. Braces can be used in line mode as
;; this example shows, or they can be used inside parenthesised S-expressions to
;; escape back to line mode. Braces implicitly act like Racket’s begin form,
;; which evaluates its sub-forms, in this case, lines, sequentially.

;; #{}   hash-brace-form
;; - implicitly set subprocess input to an empty port, converts subprocess
;;   output to a string, and trims trailing whitespace from it.

;; #%hash-braces parameterizes the default input, output, and error redirection
;; for the run-pipeline macro and executes its sub-form

;; produces the same result as a ⟨brace-form⟩, except that it is wrapped in a list
;; prefixed with #%hash-braces.

(define type
  (lambda (x)
    (cond ((number? x) "Number")
          ((pair? x) "Pair")
          ((string? x) "String")
          ((list? x) "List"))))

(require racket/undefined)

#;(require xrepl) ; interactive exploration and development

;; &bg is a background pipeline flag - like & in bash
#;(define-line-macro ee
  (lambda (stx)
    (syntax-parse stx
      [(_)          #'(run-pipeline =unix-pipe= emacs -q "./" &bg)]
      [(_ arg ...)  #'(run-pipeline =unix-pipe= emacs -q arg ... &bg)]
      )))

;; lambda not surrounded by brackets accepts any number of args, and the args
;; are put into a list bound to my-echo
;; https://docs.racket-lang.org/guide/lambda.html
(define my-echo (lambda args (displayln (string-join (map ~a args) " "))))
#;(define (my-echo args) (displayln (string-join (map ~a args) " ")))

(require racket/list)

;;; contains? : return true if list contains a given element
(define (contains? elem lst) (number? (index-of lst elem)))

(define (emacs-processes)
  (let* ([pids-str #{pgrep --exact emacs}]
         [pids (string-split pids-str)])
    (map (lambda (pid)
           (let* ([proc-user #{ps -o user= -p $pid}])
             (if (equal? (getenv "USER") proc-user)
                 (let* ([proc-cmd #{ps -o command= -p $pid}])
                   (if (string-contains? proc-cmd "defunct")
                       'zombie
                       'emacsclient))
                 'emacs)))
         pids)))

(define launch
  (lambda args
    #;(run-pipeline =unix-pipe= emacs -q $args &bg)
    (let ([emacs-cmd (if (contains? 'emacsclient (emacs-processes))
                   'emacsclient
                   'emacs)])
      #{$emacs-cmd $args &bg})))

(define-line-macro e
  (lambda (stx)
    (syntax-parse stx
      [(_)          #'(launch "./")]
      [(_ arg ...)  #'(launch `arg ...)])))

